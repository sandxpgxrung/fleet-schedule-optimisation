task 1 = dijkstars algorithm https://pypi.org/project/Dijkstar/ 
nearest-neighbour clustering? (either knn or notion-based) -> align with dijkastars algorithm?
^ NB; doesn't consider ovr path length, only considers the coord differences
-> gives quick solution (DFS -> Best First Search) -> DISADV. -> dijkstar alg. == no backtrack
-> whereas, the manual algo. create self backtrack to go back to starting node from found node FOR SHORTEST PATH
++ Self-coded BFS used for traversal\pathfinding (with backtracing)
++ greedy search used for selecting nearest nodes (customer||depot)
GOAL? by choosing the nearest nodes -> trying to minimise overall dispatch time

task 2 = genetic algorithm from scratch
neares-neighbour clustering (allocation to depot assignment for consistenc with task 1)
-- BFS for node traversal
-- Unlike greedy search, GA to order the arrangement of customers being visited by 
evaluating the overall distance per iteration... (How? possibly; keep 50% fit solutions (elitism) for next
iteration --> pushing towards more fitter solutions)
-> GA? explores solutions more optimally per iteration?
GOAL? by exploring different arrangements -> trying to find the most optimal sol. for given search constraint

Genome -> identified by the solution -> arrangement of customer list (in order -> thus mimics chromosomes)
Each genome is a routes dict. -> if lorry has capacity >= of next customer -> lorry should visit in that order. \n 
any unvisited nodes are remainders to be visited by other lorries in that depot, in same order. 

Fitness -> each chromosome has a weight (the overall traversal distance from one node to other)
so the total weight per solution is the cumulative sum of each chromosome's weight in the genome. 

Crossover -> given two genomes (so two routes dicts). swap allocated routes for certain depots (random chosen). \n 
in hopes of generating a fitter offspring. (can employ elitism here to retain fitter genomes)

Mutation -> within the allocated routes of a genome. Give random mutation probability. If true;
switch orders in which a node may be visited. (can employ elitism here)

# main loop these functions in a while iteration, given constraints. Use the fittest solution found as the 
final order in which lorry's from each depot are to visit the customers. 
